CFG and PDA: Complete Visual Guide for Beginners
==================================================

.. contents:: Navigation
   :local:
   :depth: 3

----

ğŸ“š Introduction: What Are PDAs?
================================

Imagine you're at a library. A librarian can check books IN and OUT. But a **simple counter** (like a Finite Automaton) can't remember what books are currently inside!

A **Pushdown Automaton (PDA)** is like a librarian with a **notepad (stack)** that writes down what's inside. This memory lets the PDA do **amazing things** that simple machines cannot.

.. admonition:: ğŸ’¡ Key Idea
   :class: tip

   **PDA = Finite Automaton + Stack Memory**

   Think of the stack like a **stack of plates**: you can only add or remove from the **TOP**, not the bottom!

----

Why Do We Need PDAs?
=====================

**Finite Automata Limitation**
------------------------------

Let's try to check if parentheses are balanced: ``((3 + 5) * 2)``

âŒ **Finite Automaton FAILS** because it has no memory!

- Sees first ``(`` â†’ can't remember it
- Sees second ``(`` â†’ can't remember TWO opening brackets
- Sees `)` â†’ doesn't know how many to match!

âœ… **PDA WORKS** because it has a stack!

- Sees ``(`` â†’ Push to stack
- Sees ``)`` â†’ Pop from stack
- Stack empty at end? â†’ Accept!

.. graphviz::
   :align: center
   :caption: FA Cannot Remember, PDA Can

   digraph capability {
       rankdir=LR;
       node [shape=box, style="rounded,filled", fillcolor=wheat];
       edge [fontsize=10];
       
       task [label="Task: Check\nBalanced\nParentheses", fillcolor=lightcyan];
       fa [label="Finite\nAutomaton", fillcolor=lightcoral];
       pda [label="Pushdown\nAutomaton", fillcolor=lightgreen];
       
       task -> fa [label="âœ— FAIL"];
       task -> pda [label="âœ“ WORKS"];
   }

----

PDA Components Explained Simply
================================

A PDA is defined as: :math:`M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)`

Let's break it down like building blocks:

.. list-table::
   :header-rows: 1
   :widths: 15 25 60

   * - Symbol
     - Name
     - Explanation (Simple)
   * - :math:`Q`
     - States
     - Like rooms in a house. You move between them.
   * - :math:`\Sigma`
     - Input alphabet
     - Symbols you READ from the input string (e.g., 'a', 'b', '(', ')')
   * - :math:`\Gamma`
     - Stack alphabet
     - Symbols you can WRITE on the stack (often :math:`Z_0`, 'a', 'b')
   * - :math:`\delta`
     - Transition function
     - Rules: "If in state q, read symbol 'a', stack top is 'X', then..."
   * - :math:`q_0`
     - Start state
     - The first room you enter
   * - :math:`Z_0`
     - Initial stack symbol
     - Stack starts with this symbol (usually represents "empty")
   * - :math:`F`
     - Accept states
     - Final rooms where you WIN (input accepted)

**Example Values:**

- :math:`Q = \{q_0, q_1, q_2\}` â†’ 3 states
- :math:`\Sigma = \{a, b\}` â†’ Input is just 'a' or 'b'
- :math:`\Gamma = \{Z_0, a\}` â†’ Stack can have :math:`Z_0` or 'a'

----

Stack Operations: The Core Mechanic
====================================

**What is a Stack?**

Imagine stacking plates. You can:

1. **PUSH**: Add a plate on top
2. **POP**: Remove the top plate
3. **PEEK**: Look at what's on top (don't remove)

.. graphviz::
   :align: center
   :caption: Stack Operations

   digraph stack_ops {
       rankdir=LR;
       node [shape=record, style=filled, fillcolor=lightyellow];
       edge [fontsize=10];
       
       stack1 [label="{ Start | { Zâ‚€ } }"];
       stack2 [label="{ Push 'a' | { a | Zâ‚€ } }"];
       stack3 [label="{ Push 'a' | { a | a | Zâ‚€ } }"];
       stack4 [label="{ Pop 'a' | { a | Zâ‚€ } }"];
       stack5 [label="{ Pop 'a' | { Zâ‚€ } }", fillcolor=lightgreen];
       
       stack1 -> stack2 -> stack3 -> stack4 -> stack5;
   }

**Transition Notation:**

When we write: :math:`\delta(q, a, X) \to (p, YZ)`

This means:
- **Current state**: q
- **Read input**: a
- **Stack top**: X
- **New state**: p
- **Stack action**: Pop X, Push Y then Z

----

ğŸ¯ Example 1: PDA for :math:`L = \{a^nb^n \mid n \geq 1\}`
=============================================================

**What is this language?**

Equal number of 'a's followed by equal number of 'b's:

- âœ“ ``ab`` (1 a, 1 b)
- âœ“ ``aabb`` (2 a's, 2 b's)
- âœ“ ``aaabbb`` (3 a's, 3 b's)
- âœ— ``aab`` (2 a's, 1 b) - NOT EQUAL
- âœ— ``baa`` (b before a) - WRONG ORDER

**Strategy to Build PDA:**

1. **Reading a's phase**: PUSH each 'a' to stack
2. **Reading b's phase**: POP for each 'b'
3. **Accept condition**: Stack empty when input ends

**The PDA Design:**

.. graphviz::
   :align: center
   :caption: PDA for aâ¿bâ¿ - Color Coded States

   digraph pda_anbn {
       rankdir=LR;
       node [shape=circle, style=filled];
       edge [fontsize=11];
       
       qi [shape=point, style=none];
       q0 [label="qâ‚€", fillcolor=lightgreen, tooltip="START"];
       q1 [label="qâ‚", fillcolor=lightyellow, tooltip="READING"];
       q2 [label="qâ‚‚", shape=doublecircle, fillcolor=lightcoral, tooltip="ACCEPT"];
       
       qi -> q0;
       q0 -> q1 [label="a, Zâ‚€ â†’ aZâ‚€\n(First 'a')"];
       q1 -> q1 [label="a, a â†’ aa\n(Push more)"];
       q1 -> q1 [label="b, a â†’ Îµ\n(Pop for 'b')", style=dashed];
       q1 -> q2 [label="Îµ, Zâ‚€ â†’ Zâ‚€\n(Accept)", color=green];
   }

**Line-by-Line Explanation:**

.. list-table::
   :header-rows: 1
   :widths: 10 15 15 30 30

   * - Step
     - State
     - Input
     - Stack Top
     - Action â†’ New Stack
   * - 1
     - :math:`q_0`
     - Read 'a'
     - :math:`Z_0`
     - Push 'a' â†’ :math:`aZ_0`
   * - 2
     - :math:`q_1`
     - Read 'a'
     - 'a'
     - Push 'a' â†’ :math:`aaZ_0`
   * - 3
     - :math:`q_1`
     - Read 'b'
     - 'a'
     - Pop 'a' â†’ :math:`aZ_0`
   * - 4
     - :math:`q_1`
     - Read 'b'
     - 'a'
     - Pop 'a' â†’ :math:`Z_0`
   * - 5
     - :math:`q_1`
     - No more input
     - :math:`Z_0`
     - Move to :math:`q_2` â†’ ACCEPT!

**Complete Trace for "aabb":**

.. code-block:: text

   Configuration                Input Remaining    Stack
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Start: (qâ‚€, "aabb", Zâ‚€)           aabb             [Zâ‚€]
   Step 1: (qâ‚, "abb", Zâ‚€)            abb              [aZâ‚€]
   Step 2: (qâ‚, "bb", Zâ‚€)              bb              [aaZâ‚€]
   Step 3: (qâ‚, "b", Zâ‚€)               b               [aZâ‚€]
   Step 4: (qâ‚, Îµ, Zâ‚€)                 Îµ               [Zâ‚€]
   Step 5: (qâ‚‚, Îµ, Zâ‚€)                 Îµ               [Zâ‚€]  âœ“ ACCEPT

**Rejected Trace for "aab":**

.. code-block:: text

   Configuration                Input Remaining    Stack
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Start: (qâ‚€, "aab", Zâ‚€)           aab              [Zâ‚€]
   Step 1: (qâ‚, "ab", Zâ‚€)            ab               [aZâ‚€]
   Step 2: (qâ‚, "b", Zâ‚€)              b               [aaZâ‚€]
   Step 3: (qâ‚, Îµ, Zâ‚€)                Îµ               [aZâ‚€]  â† Stack NOT empty!
   Result: (qâ‚, Îµ, Zâ‚€)                                âœ— REJECT

.. admonition:: ğŸ”‘ Learn This!
   :class: important

   **The key insight**: We need **exactly** as many pops as pushes. If one is left over, reject!

----

ğŸ¯ Example 2: PDA for Balanced Parentheses
=============================================

**Language**: Strings with properly nested parentheses

- âœ“ ``()``
- âœ“ ``(())``
- âœ“ ``()(())``
- âœ— ``)(`` - Wrong order
- âœ— ``(()`` - Missing closing

**Strategy:**

1. Push '(' to stack
2. For each ')', pop a '('
3. Stack empty at end = balanced!

.. graphviz::
   :align: center
   :caption: PDA for Balanced Parentheses

   digraph balanced_parens {
       rankdir=LR;
       node [shape=circle, style=filled];
       
       qi [shape=point, style=none];
       q0 [label="qâ‚€", fillcolor=lightgreen];
       q1 [label="qâ‚", fillcolor=lightyellow];
       q2 [label="qâ‚‚", shape=doublecircle, fillcolor=lightcoral];
       
       qi -> q0;
       q0 -> q1 [label="(, Zâ‚€ â†’ (Zâ‚€"];
       q1 -> q1 [label="(, ( â†’ (("];
       q1 -> q1 [label="), ( â†’ Îµ"];
       q1 -> q2 [label="Îµ, Zâ‚€ â†’ Zâ‚€"];
   }

**Trace for "(())":**

.. code-block:: text

   (qâ‚€, "(())", Zâ‚€)
     â†’ (qâ‚, "())", (Zâ‚€)
     â†’ (qâ‚, ")", ((Zâ‚€)      [pushed another (]
     â†’ (qâ‚, ")", (Zâ‚€)       [popped one (]
     â†’ (qâ‚, Îµ, Zâ‚€)          [popped final (]
     â†’ (qâ‚‚, Îµ, Zâ‚€)          âœ“ ACCEPT

----

ğŸ¯ Example 3: PDA for Palindromes :math:`a^nb^na^n`
=====================================================

**Language**: a's, then b's, then same number of a's again

- âœ“ ``aba`` (1 a, 1 b, 1 a)
- âœ“ ``aabbaa`` (2 a's, 2 b's, 2 a's)
- âœ— ``aba`` â†’ wait, that's only 2 a's total, not 1+1
- Actually: âœ“ ``aba``, âœ“ ``aabbaa``, âœ“ ``aaabbbaaa``

**Strategy:**

1. Push for each first group of 'a's
2. Read b's (don't change stack)
3. Pop for each final group of 'a's
4. Stack empty = palindrome!

.. graphviz::
   :align: center
   :caption: PDA for aâ¿bâ¿aâ¿

   digraph palindrome {
       rankdir=LR;
       node [shape=circle, style=filled];
       
       qi [shape=point, style=none];
       q0 [label="qâ‚€\n(Push a's)", fillcolor=lightgreen];
       q1 [label="qâ‚\n(Read b's)", fillcolor=lightyellow];
       q2 [label="qâ‚‚\n(Pop a's)", fillcolor=lightblue];
       q3 [label="qâ‚ƒ", shape=doublecircle, fillcolor=lightcoral];
       
       qi -> q0;
       q0 -> q0 [label="a, a â†’ aa\na, Zâ‚€ â†’ aZâ‚€"];
       q0 -> q1 [label="b, a â†’ a\nÎµ (transition)"];
       q1 -> q1 [label="b, a â†’ a"];
       q1 -> q2 [label="Îµ, a â†’ a\n(switch)"];
       q2 -> q2 [label="a, a â†’ Îµ"];
       q2 -> q3 [label="Îµ, Zâ‚€ â†’ Zâ‚€"];
   }

----

ğŸ¯ Example 4: PDA for :math:`L = \{a^nb^{2n} \mid n \geq 1\}`
==============================================================

**What is this?**

For every 'a', there are **2 b's**

- âœ“ ``abb`` (1 a, 2 b's)
- âœ“ ``aabbbb`` (2 a's, 4 b's)
- âœ— ``abbb`` (1 a, 3 b's) - Not 2Ã— number of a's

**Key Difference**: For each 'a', we push **TWO** symbols!

.. graphviz::
   :align: center
   :caption: PDA for aâ¿bÂ²â¿

   digraph a_n_b_2n {
       rankdir=LR;
       node [shape=circle, style=filled];
       
       qi [shape=point, style=none];
       q0 [label="qâ‚€", fillcolor=lightgreen];
       q1 [label="qâ‚", fillcolor=lightyellow];
       q2 [label="qâ‚‚", shape=doublecircle, fillcolor=lightcoral];
       
       qi -> q0;
       q0 -> q1 [label="a, Zâ‚€ â†’ aaZâ‚€\n(Push TWO a's)"];
       q1 -> q1 [label="a, a â†’ aaa\n(Push two more)"];
       q1 -> q1 [label="b, a â†’ Îµ\n(Pop one)"];
       q1 -> q2 [label="Îµ, Zâ‚€ â†’ Zâ‚€"];
   }

**Trace for "aabbbb":**

.. code-block:: text

   (qâ‚€, "aabbbb", Zâ‚€)
     â†’ (qâ‚, "abbbb", aaZâ‚€)      [Pushed two a's for first 'a']
     â†’ (qâ‚, "bbbb", aaaaZâ‚€)     [Pushed two more a's]
     â†’ (qâ‚, "bbb", aaaZâ‚€)       [Popped one 'a']
     â†’ (qâ‚, "bb", aaZâ‚€)         [Popped one 'a']
     â†’ (qâ‚, "b", aZâ‚€)           [Popped one 'a']
     â†’ (qâ‚, Îµ, Zâ‚€)              [Popped one 'a']
     â†’ (qâ‚‚, Îµ, Zâ‚€)              âœ“ ACCEPT (4 b's = 2Ã—2 a's)

----

CFG and PDA: Are They the Same?
================================

**Yes!** They have the **same power**!

- **CFG** (Context-Free Grammar) - **Generates** strings
- **PDA** (Pushdown Automaton) - **Recognizes** strings

.. graphviz::
   :align: center
   :caption: CFG and PDA Describe the Same Languages

   digraph cfg_pda_equiv {
       rankdir=LR;
       node [shape=box, style="rounded,filled"];
       
       CFG [label="Context-Free\nGrammar\n(Rules for building)", fillcolor=lightblue];
       PDA [label="Pushdown\nAutomaton\n(Rules for checking)", fillcolor=lightgreen];
       
       CFG -> PDA [label="Equivalent\nPower", dir=both, style=bold, color=red];
   }

**Example Conversion:**

**CFG Rule**: :math:`S \to aSb \mid \epsilon`

**Translation to PDA logic**:

1. Start with 'S' on stack
2. When we see 'S': either use rule :math:`aSb` or :math:`\epsilon`
3. If :math:`aSb`: push 'S' and 'a', 'b'
4. Match terminals with input

----

ğŸ“ Introduction to CFG â†’ PDA Conversion
========================================

**The Recipe:**

1. Push starting non-terminal to stack
2. When stack top is non-terminal, replace with production right side
3. When stack top is terminal, match with input symbol
4. Accept when both input and stack are empty

**Example CFG:**

:math:`S \to aSb | ab`

**PDA Transitions:**

.. list-table::
   :header-rows: 1
   :widths: 20 20 20 20 20

   * - State
     - Input
     - Stack Top
     - New State
     - New Stack
   * - :math:`q`
     - :math:`\epsilon`
     - S
     - :math:`q`
     - :math:`aSb`
   * - :math:`q`
     - :math:`\epsilon`
     - S
     - :math:`q`
     - :math:`ab`
   * - :math:`q`
     - a
     - a
     - :math:`q`
     - :math:`\epsilon`
   * - :math:`q`
     - b
     - b
     - :math:`q`
     - :math:`\epsilon`

**Visual Flow:**

.. graphviz::
   :align: center
   :caption: CFG to PDA Conversion Flow

   digraph cfg_conversion {
       rankdir=TB;
       node [shape=box, style="rounded,filled", fillcolor=wheat];
       edge [fontsize=9];
       
       cfg [label="CFG\nS â†’ aSb | ab"];
       step1 [label="Initialize\nPush 'S'", fillcolor=lightblue];
       step2 [label="See rule Sâ†’aSb\nReplace", fillcolor=lightyellow];
       step3 [label="Match 'a'\nPop 'a'", fillcolor=lightcyan];
       step4 [label="Recursively\nreplace 'S'", fillcolor=lightyellow];
       step5 [label="Match b's\nPop 'b'", fillcolor=lightcyan];
       pda [label="PDA Accepts", fillcolor=lightgreen];
       
       cfg -> step1 -> step2 -> step3 -> step4 -> step5 -> pda;
   }

----

ğŸ“ Practice Problems with Solutions
====================================

Practice Problem 1: Design PDA for :math:`L = \{a^nb^m \mid n \leq m\}`
-----------------------------------------------------------------------

**Question**: Design a PDA that accepts strings where the number of a's is **less than or equal to** the number of b's.

- âœ“ ``ab``
- âœ“ ``abb``
- âœ“ ``aabb``
- âœ“ ``b``
- âœ— ``aabb`` where n > m

**Your turn! Try before looking at solution.**

.. admonition:: ğŸ’¡ Hint
   :class: hint

   What's different from :math:`a^nb^n`? Here b's can be **extra**. So what happens to extra b's?

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   Strategy:
   - Push one symbol for each 'a'
   - Pop one symbol for each 'b' 
   - EXTRA b's: just read them (no pop)
   - Accept when input ends
   
   Key Insight: We don't reject if extra b's are left to read!

   Transitions:
   Î´(qâ‚€, a, Zâ‚€) â†’ (qâ‚, aZâ‚€)         [First 'a': push]
   Î´(qâ‚, a, a) â†’ (qâ‚, aa)           [More a's: push]
   Î´(qâ‚, b, a) â†’ (qâ‚, Îµ)            [Pop for b]
   Î´(qâ‚, b, Zâ‚€) â†’ (qâ‚, Zâ‚€)          [Extra b: ignore]
   Î´(qâ‚, Îµ, Zâ‚€) â†’ (qâ‚‚, Zâ‚€)          [Accept]
   
   State Diagram:
   
                      a,Zâ‚€â†’aZâ‚€
        qâ‚€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ qâ‚ â†â”€â”€â”€â”€â”€â”€â”
                          â†™ â†˜        â”‚
                      a,a/aa  b,a/Îµ  â”‚
                          â†™ â†˜        â”‚
                      b,Zâ‚€/Zâ‚€ â”€â”€â”€â”€â”€â”€â”€â”˜
                      Îµ,Zâ‚€/Zâ‚€
                          â†“
                          qâ‚‚ (accept)

.. raw:: html

   </details>

----

Practice Problem 2: Write CFG for :math:`L = \{a^mb^n \mid m,n \geq 0\}`
------------------------------------------------------------------------

**Question**: Write a Context-Free Grammar for any number of a's followed by any number of b's (including empty strings).

- âœ“ ``Îµ`` (empty)
- âœ“ ``aaa``
- âœ“ ``bbb``
- âœ“ ``aaabbb``
- âœ“ ``a``
- âœ“ ``b``

**Your turn!**

.. admonition:: ğŸ’¡ Hint
   :class: hint

   You need **three** productions: one for a's, one for b's, one to combine them.

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   CFG Solution:
   
   S â†’ AB
   A â†’ aA | Îµ
   B â†’ bB | Îµ
   
   Explanation:
   - S generates the whole string (a's then b's)
   - A generates zero or more a's
   - B generates zero or more b's
   
   Example derivations:
   S â‡’ AB â‡’ aAB â‡’ aaAB â‡’ aaAB â‡’ aaB 
     â‡’ aabB â‡’ aabbB â‡’ aabb
   
   Result: "aabb" âœ“

.. raw:: html

   </details>

----

Practice Problem 3: Convert CFG to PDA
--------------------------------------

**Question**: Convert this CFG to a PDA:

.. math::

   S \to aSb \mid \epsilon

**Your turn! What are the transitions?**

.. admonition:: ğŸ’¡ Hint
   :class: hint

   You need states for: (1) Initialize S, (2) Apply productions, (3) Match terminals.

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   PDA Transitions:
   
   State: q (single state)
   
   1. Î´(q, Îµ, S) â†’ (q, aSb)    [Production: S â†’ aSb]
   2. Î´(q, Îµ, S) â†’ (q, Îµ)      [Production: S â†’ Îµ]
   3. Î´(q, a, a) â†’ (q, Îµ)      [Match terminal 'a']
   4. Î´(q, b, b) â†’ (q, Îµ)      [Match terminal 'b']
   
   Initial: q with S on stack
   Accept: when input AND stack are BOTH empty
   
   Trace for "aabb":
   
   (q, aabb, S)
     â†’ (q, aabb, aSb)        [Apply Sâ†’aSb]
     â†’ (q, abb, Sb)          [Match 'a']
     â†’ (q, abb, aSbb)        [Apply Sâ†’aSb again]
     â†’ (q, bb, Sbb)          [Match 'a']
     â†’ (q, bb, Îµ bb)         [Apply Sâ†’Îµ]
     â†’ (q, b, bb)            [Match 'b']
     â†’ (q, Îµ, b)             [Match 'b']
     âœ— FAIL: Stack not empty!
   
   Actually, let me retrace:
   (q, aabb, S)
     â†’ (q, aabb, aSb)       [Sâ†’aSb]
     â†’ (q, abb, Sb)         [Pop 'a']
     â†’ (q, abb, Îµ b)        [Sâ†’Îµ]
     â†’ (q, abb, b)          [Pop nothing]
     âœ“ ACCEPT (string matches production)

.. raw:: html

   </details>

----

Practice Problem 4: Trace and Verify
--------------------------------------

**Question**: Given string "aaabbb", trace through the PDA for :math:`a^nb^n` and determine if it's accepted or rejected.

**Show each step with:**
- Current state
- Input remaining
- Stack contents

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   PDA for aâ¿bâ¿:
   Î´(qâ‚€, a, Zâ‚€) â†’ (qâ‚, aZâ‚€)
   Î´(qâ‚, a, a) â†’ (qâ‚, aa)
   Î´(qâ‚, b, a) â†’ (qâ‚, Îµ)
   Î´(qâ‚, Îµ, Zâ‚€) â†’ (qâ‚‚, Zâ‚€)
   
   Trace for "aaabbb":
   
   Step  State  Input      Stack      Action
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   0     qâ‚€     aaabbb     Zâ‚€         Start
   1     qâ‚     aabbb      aZâ‚€        Read 'a', push 'a'
   2     qâ‚     abbb       aaZâ‚€       Read 'a', push 'a'
   3     qâ‚     bbb        aaaZâ‚€      Read 'a', push 'a'
   4     qâ‚     bb         aaZâ‚€       Read 'b', pop 'a'
   5     qâ‚     b          aZâ‚€        Read 'b', pop 'a'
   6     qâ‚     Îµ          Zâ‚€         Read 'b', pop 'a'
   7     qâ‚‚     Îµ          Zâ‚€         Îµ-transition, ACCEPT
   
   Result: âœ“ ACCEPTED (3 a's matched 3 b's)

.. raw:: html

   </details>

----

Practice Problem 5: Language Recognition
------------------------------------------

**Question**: Can a PDA recognize :math:`L = \{a^nb^nc^n \mid n \geq 1\}`?

Why or why not?

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   Answer: NO âœ—
   
   Reason: A PDA has only ONE stack, and you can only access the TOP.
   
   Why it fails:
   - Push for each 'a' âœ“
   - Pop for each 'b' âœ“
   - But then check 'c's:
     - We've already popped all a's from stack!
     - Stack just has Zâ‚€
     - How do we verify c's match original a's?
   
   Example: "aabbcc" vs "aabcc"
   - Both: push 2, pop 2, read c's
   - But which one is correct?
   
   Solution: You need TWO stacks â†’ Turing Machine!
   
   Key Learning: PDAs can match TWO related groups, 
                 but NOT THREE independent groups.

.. raw:: html

   </details>

----

Practice Problem 6: Design Your Own PDA
-----------------------------------------

**Question**: Design a PDA for :math:`L = \{wcw^R \mid w \in \{a,b\}^*\}`

This is a **palindrome with center marker 'c'**

- âœ“ ``c`` (empty w)
- âœ“ ``aca`` (w = a)
- âœ“ ``abcba`` (w = ab)
- âœ— ``abccba`` (doesn't use center)

**Strategy:**

1. Phase 1: Read left part, push to stack
2. Phase 2: See 'c', switch mode
3. Phase 3: Read right part, pop and match

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   Transitions:
   
   Î´(qâ‚€, a, Zâ‚€) â†’ (qâ‚€, aZâ‚€)      [Push 'a']
   Î´(qâ‚€, b, Zâ‚€) â†’ (qâ‚€, bZâ‚€)      [Push 'b']
   Î´(qâ‚€, a, a) â†’ (qâ‚€, aa)        [Push more]
   Î´(qâ‚€, a, b) â†’ (qâ‚€, ab)        [Push 'a' on top of 'b']
   Î´(qâ‚€, b, a) â†’ (qâ‚€, ba)        [Push 'b' on top of 'a']
   Î´(qâ‚€, b, b) â†’ (qâ‚€, bb)        [Push more]
   
   Î´(qâ‚€, c, Zâ‚€) â†’ (qâ‚, Zâ‚€)       [See 'c', switch mode]
   Î´(qâ‚€, c, a) â†’ (qâ‚, a)         [See 'c' on non-empty stack]
   Î´(qâ‚€, c, b) â†’ (qâ‚, b)         [See 'c' on non-empty stack]
   
   Î´(qâ‚, a, a) â†’ (qâ‚, Îµ)         [Match 'a', pop]
   Î´(qâ‚, b, b) â†’ (qâ‚, Îµ)         [Match 'b', pop]
   
   Î´(qâ‚, Îµ, Zâ‚€) â†’ (qâ‚‚, Zâ‚€)       [Accept on empty stack]
   
   Trace for "abcba":
   
   (qâ‚€, abcba, Zâ‚€)
     â†’ (qâ‚€, bcba, aZâ‚€)           [Push 'a']
     â†’ (qâ‚€, cba, baZâ‚€)           [Push 'b']
     â†’ (qâ‚, ba, baZâ‚€)            [Saw 'c', switch to qâ‚]
     â†’ (qâ‚, a, aZâ‚€)              [Match 'b', pop]
     â†’ (qâ‚, Îµ, Zâ‚€)               [Match 'a', pop]
     â†’ (qâ‚‚, Îµ, Zâ‚€)               [Accept]
     
   Result: âœ“ ACCEPTED

.. raw:: html

   </details>

----

Practice Problem 7: Multiple Choice
-------------------------------------

**Question**: Which string is accepted by PDA for :math:`a^nb^nc^n`?

A) ``aabbcc``  
B) ``aaabbbccc``  
C) ``None of them``

.. raw:: html

   <details>
   <summary><strong>âœ… SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   Answer: C) None of them âœ—
   
   Explanation:
   A PDA with ONE stack cannot verify THREE equal-length groups.
   
   aabbcc:
   - Stack after a's: [a, a, Zâ‚€]
   - After matching b's: [Zâ‚€]
   - How to verify 2 c's match? Stack is already empty!
   
   Conclusion: This language is NOT context-free.
   It requires a Turing Machine (2+ stacks or unlimited memory).

.. raw:: html

   </details>

----

ğŸ“Š Quick Reference Table
==========================

.. list-table::
   :header-rows: 1
   :widths: 20 30 20 30

   * - Language
     - Notation
     - Can PDA do it?
     - Reason
   * - Equal a's and b's
     - :math:`a^nb^n`
     - âœ“ YES
     - Stack matches pairs
   * - More b's than a's
     - :math:`a^nb^m (n<m)`
     - âœ“ YES
     - Stack can ignore extras
   * - Three equal groups
     - :math:`a^nb^nc^n`
     - âœ— NO
     - Only 1 stack, not enough
   * - Palindromes
     - :math:`wcw^R`
     - âœ“ YES
     - Push then pop in reverse
   * - Balanced parens
     - :math:`(^n)^n`
     - âœ“ YES
     - Push ( pop )
   * - Nested parens
     - :math:`(((...)))`
     - âœ“ YES
     - Stack tracks nesting

----

ğŸ’¡ Common Mistakes to Avoid
=============================

**Mistake 1: Forgetting to initialize stack**

âŒ Wrong: Start with empty stack  
âœ“ Correct: Start with :math:`Z_0` symbol

**Mistake 2: Popping when stack is empty**

âŒ Wrong: Pop 'a' when stack has 'Zâ‚€'  
âœ“ Correct: Define separate transition for :math:`Z_0`

**Mistake 3: Not accepting on empty input**

âŒ Wrong: Accept only when stack is empty  
âœ“ Correct: Accept when BOTH input AND stack are empty

**Mistake 4: Confusing PDA limitations**

âŒ Wrong: "PDA can recognize anything"  
âœ“ Correct: "PDA recognizes context-free languages only"

**Mistake 5: Wrong transition notation**

âŒ Wrong: :math:`\delta(q, a, X) \to (p, Y, Z)` (4 things)  
âœ“ Correct: :math:`\delta(q, a, X) \to (p, YZ)` (state, stack action)

----

ğŸ¯ Key Takeaways
=================

.. admonition:: âœ… Remember This!
   :class: important

   1. **PDA = FA + Stack**: Adds ONE memory structure
   
   2. **Stack Operations**: PUSH, POP, or leave alone (3 choices per transition)
   
   3. **Acceptance**: Input CONSUMED + Stack EMPTY = Accept
   
   4. **Language Power**: Context-Free Languages
   
   5. **Matching Pairs**: PDAs excel at :math:`a^nb^n` style patterns
   
   6. **Limitation**: Only one stack (can't do :math:`a^nb^nc^n`)
   
   7. **CFG â†” PDA**: Equivalent power, different perspectives

----

ğŸ“– Next Steps
==============

1. **Practice** converting between CFG and PDA
2. **Try harder** languages like :math:`a^nb^{2n}`
3. **Study** when PDAs fail (e.g., :math:`a^nb^nc^n`)
4. **Learn** Turing Machines for unlimited power

----

*End of Complete Guide for Beginners*

âœ¨ **Good luck with your studies!** âœ¨
